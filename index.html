<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>벽바둑</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(7, 60px);
      grid-template-rows: repeat(7, 60px);
      gap: 2px;
    }
    .cell {
      width: 60px;
      height: 60px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    .player1 {
      background-color: #ff6666;
      border-radius: 50%;
      width: 40px;
      height: 40px;
    }
    .player2 {
      background-color: #66aaff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
    }
    .wall-top, .wall-right, .wall-bottom, .wall-left {
      position: absolute;
    }
    .wall-top    { top: 0; left: 0; right: 0; height: 2px; }
    .wall-right  { top: 0; right: 0; bottom: 0; width: 2px; }
    .wall-bottom { bottom: 0; left: 0; right: 0; height: 2px; }
    .wall-left   { top: 0; left: 0; bottom: 0; width: 2px; }
    .wall-player1 { background-color: red !important; }
    .wall-player2 { background-color: blue !important; }
    .selected { filter: brightness(0.6); }
    #status {
      margin-top: 20px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>벽바둑</h1>
  <div id="board"></div>
  <div id="status">말을 배치하세요. 현재: 플레이어 1</div>
  <audio id="wallSound" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg"></audio>
  <script>
    const boardSize = 7;
    const board = [];
    const pieces = [[], []];
    const boardElement = document.getElementById("board");
    const statusElement = document.getElementById("status");

    let gameState = "placement";
    let currentPlayer = 1;
    let pieceCounts = [0, 0];
    const maxPieces = 4;
    let selectedPiece = null;
    let timer = null;

    const opposite = dir => ({ top: "bottom", bottom: "top", left: "right", right: "left" })[dir];

    function createCell(x, y) {
      const div = document.createElement("div");
      div.className = "cell";
      div.dataset.x = x;
      div.dataset.y = y;
      div.addEventListener("click", () => handleCellClick(x, y));
      return div;
    }

    function initBoard() {
      for (let y = 0; y < boardSize; y++) {
        board[y] = [];
        for (let x = 0; x < boardSize; x++) {
          const cell = createCell(x, y);
          board[y][x] = { piece: 0, element: cell, walls: { top: false, right: false, bottom: false, left: false } };
          boardElement.appendChild(cell);
        }
      }
    }

    function handleCellClick(x, y) {
      const cell = board[y][x];
      if (gameState === "placement") {
        if (cell.piece === 0 && pieceCounts[currentPlayer - 1] < maxPieces) {
          cell.piece = currentPlayer;
          const piece = document.createElement("div");
          piece.className = currentPlayer === 1 ? "player1" : "player2";
          cell.element.appendChild(piece);
          pieceCounts[currentPlayer - 1]++;
          pieces[currentPlayer - 1].push({ x, y });

          if (pieceCounts[0] === maxPieces && pieceCounts[1] === maxPieces) {
            gameState = "selecting";
            statusElement.innerText = "게임 시작! 플레이어 1, 말을 선택하세요.";
            startTimer();
          } else {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            statusElement.innerText = `말을 배치하세요. 현재: 플레이어 ${currentPlayer}`;
          }
        }
      } else if (gameState === "selecting") {
        if (cell.piece === currentPlayer) {
          selectedPiece = { x, y };
          gameState = "moving";
          clearHighlights();
          cell.element.querySelector(".player" + currentPlayer).classList.add("selected");
          statusElement.innerText = `플레이어 ${currentPlayer}, 이동할 위치를 선택하세요.`;
        }
      } else if (gameState === "moving") {
        if (board[y][x].piece === 0 && isPathWithinTwoSteps(selectedPiece.x, selectedPiece.y, x, y)) {
          if (!isBlocked(selectedPiece.x, selectedPiece.y, x, y)) {
            const old = board[selectedPiece.y][selectedPiece.x];
            const pieceElem = old.element.querySelector(".player" + currentPlayer);
            old.piece = 0;
            if (pieceElem) old.element.removeChild(pieceElem);
            const newCell = board[y][x];
            newCell.piece = currentPlayer;
            const newPiece = document.createElement("div");
            newPiece.className = currentPlayer === 1 ? "player1" : "player2";
            newCell.element.appendChild(newPiece);
            selectedPiece = { x, y };
            clearHighlights();
            gameState = "placing";
            statusElement.innerText = "방향키(↑↓←→)로 벽을 설치하세요.";
            listenForWallKey(x, y);
          } else {
            statusElement.innerText = "벽으로 막혀 이동할 수 없습니다.";
          }
        }
      }
    }

    function clearHighlights() {
      document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
    }

    function isPathWithinTwoSteps(x1, y1, x2, y2) {
      const visited = Array.from({ length: boardSize }, () => Array(boardSize).fill(false));
      const queue = [{ x: x1, y: y1, depth: 0 }];
      while (queue.length > 0) {
        const { x, y, depth } = queue.shift();
        if (x === x2 && y === y2 && depth > 0 && depth <= 2) return true;
        if (depth >= 2) continue;
        for (const [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < boardSize && ny < boardSize &&
              !visited[ny][nx] && !isBlocked(x, y, nx, ny) && board[ny][nx].piece === 0) {
            visited[ny][nx] = true;
            queue.push({ x: nx, y: ny, depth: depth + 1 });
          }
        }
      }
      return false;
    }

    function isBlocked(x1, y1, x2, y2) {
      const dx = x2 - x1, dy = y2 - y1;
      if (dx === 1) return board[y1][x1].walls.right;
      if (dx === -1) return board[y1][x1].walls.left;
      if (dy === 1) return board[y1][x1].walls.bottom;
      if (dy === -1) return board[y1][x1].walls.top;
      return true;
    }
    function listenForWallKey(x, y) {
      function onKey(e) {
        if (gameState !== "placing") return;
        const keyMap = {
          ArrowUp: "top",
          ArrowDown: "bottom",
          ArrowLeft: "left",
          ArrowRight: "right"
        };
        const dir = keyMap[e.key];
        if (!dir) return;
        if (board[y][x].walls[dir]) {
          statusElement.innerText = "이미 벽이 있는 방향입니다.";
          return;
        }
        setWall(x, y, dir);
        playWallSound();
        checkSeparation();
        if (gameState !== "ended") {
          gameState = "selecting";
          currentPlayer = currentPlayer === 1 ? 2 : 1;
          statusElement.innerText = `플레이어 ${currentPlayer}, 말을 선택하세요.`;
          resetTimer();
          startTimer();
        }
        window.removeEventListener("keydown", onKey);
      }
      window.addEventListener("keydown", onKey);
    }

    function setWall(x, y, dir) {
      const cell = board[y][x];
      if (cell.walls[dir]) return;
      cell.walls[dir] = true;
      const wallDiv = document.createElement("div");
      wallDiv.className = `wall-${dir} wall-player${currentPlayer}`;
      cell.element.appendChild(wallDiv);

      const dxdy = { top: [0, -1], bottom: [0, 1], left: [-1, 0], right: [1, 0] };
      const [dx, dy] = dxdy[dir];
      const nx = x + dx, ny = y + dy;
      const opp = opposite(dir);
      if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize) {
        board[ny][nx].walls[opp] = true;
        const adjWall = document.createElement("div");
        adjWall.className = `wall-${opp} wall-player${currentPlayer}`;
        board[ny][nx].element.appendChild(adjWall);
      }
    }

    function playWallSound() {
      const audio = document.getElementById("wallSound");
      audio.currentTime = 0;
      audio.play();
    }

    function startTimer() {
      let timeLeft = 90;
      clearInterval(timer);
      timer = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          clearInterval(timer);
          const directions = ["top", "right", "bottom", "left"].filter(d => !board[selectedPiece.y][selectedPiece.x].walls[d]);
          if (directions.length > 0) {
            const dir = directions[Math.floor(Math.random() * directions.length)];
            setWall(selectedPiece.x, selectedPiece.y, dir);
            playWallSound();
            checkSeparation();
          }
          if (gameState !== "ended") {
            gameState = "selecting";
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            statusElement.innerText = `시간 초과! 자동 벽 설치됨\n플레이어 ${currentPlayer}, 말을 선택하세요.`;
            resetTimer();
            startTimer();
          }
        }
      }, 1000);
    }

    function resetTimer() {
      clearInterval(timer);
    }

    function checkSeparation() {
      const visited = Array.from({ length: boardSize }, () => Array(boardSize).fill(0));
      const scores = [0, 0];
      const queue = [[], []];

      for (let i = 0; i < 2; i++) {
        for (const { x, y } of pieces[i]) {
          if (visited[y][x] === 0) {
            visited[y][x] = i + 1;
            queue[i].push({ x, y });
          }
        }
      }

      for (let i = 0; i < 2; i++) {
        while (queue[i].length) {
          const { x, y } = queue[i].shift();
          scores[i]++;
          for (const [dx, dy, dir] of [[0,1,"bottom"],[1,0,"right"],[0,-1,"top"],[-1,0,"left"]]) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < boardSize && ny < boardSize &&
                visited[ny][nx] === 0 &&
                !board[y][x].walls[dir] &&
                !board[ny][nx].walls[opposite(dir)]) {
              visited[ny][nx] = i + 1;
              queue[i].push({ x: nx, y: ny });
            }
          }
        }
      }

      let separated = true;
      for (let y = 0; y < boardSize; y++) {
        for (let x = 0; x < boardSize; x++) {
          if (visited[y][x] === 1 || visited[y][x] === 2) {
            for (const [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < boardSize && ny < boardSize &&
                  visited[ny][nx] !== 0 && visited[ny][nx] !== visited[y][x]) {
                separated = false;
              }
            }
          }
        }
      }

      if (separated) {
        gameState = "ended";
        if (scores[0] > scores[1]) {
          statusElement.innerText = `게임 종료! 플레이어 1 승리\nP1=${scores[0]} / P2=${scores[1]}`;
        } else if (scores[1] > scores[0]) {
          statusElement.innerText = `게임 종료! 플레이어 2 승리\nP1=${scores[0]} / P2=${scores[1]}`;
        } else {
          statusElement.innerText = `게임 종료! 무승부\nP1=${scores[0]} / P2=${scores[1]}`;
        }
      }
    }

    initBoard();
  </script>
</body>
</html>
